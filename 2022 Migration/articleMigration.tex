\documentclass{elsarticle}
\usepackage{graphicx}
%\usepackage{multicol}
%\usepackage{footmisc}
\usepackage{amstext}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[english]{babel}
%\usepackage[official,right]{eurosym}
\selectlanguage{english}
\hyphenation{ExecEngine}
\newtheorem{lemma}{Lemma}
\def\Events{{\mathit E}}
\begin{document}
\include{preambleMigrations}

\title{A Theory for Migration of Information Systems}
\author[ou,ordina]{Stef Joosten\fnref{fn1}}
\ead{stef.joosten@ou.nl}
\author[umn]{Sebastiaan Joosten\fnref{fn2}}
\address[ou]{Open Universiteit Nederland, Heerlen, the Netherlands}
\address[ordina]{Ordina NV, Nieuwegein, the Netherlands}
\address[umn]{University of Minnesota, Minneapolis, USA}
\fntext[fn1]{ORCID 0000-0001-8308-0189}
\fntext[fn2]{ORCID 0000-0002-6590-6220}

\begin{abstract}
	The Ampersand project has provided the theory and tools to generate semantic information systems from an algebraic specification.
	However, information systems in practice may change repeatedly after their maiden deployment.
	Changes that affect the data model typically result in a data migration.
	In such cases, simply regenerating the system is not enough.

	In this contribution we develop a theory for data migration that aims at automating the migration,
	to enable more frequent migrations.
	A theory is needed to do this reliably, without mistakes.
	This paper proposes such a theory.

	The ultimate target is to generate the entire migration from two specifications: the as-is specification and the to-be specification.
	The theory for doing that is the topic of this paper.
	The software generator that embodies this theory is subject of future research.
\end{abstract}

\begin{keyword}
relation algebra\sep software development\sep data migration\sep software migration\sep Ampersand
\end{keyword}
\maketitle

\section{Introduction}
\label{sct:Introduction}

\section{Basics}
\label{sct:Basics}
	To define migration, we must introduce the notion of dataset because migration aims to preserve data whilst changing the software that manipulates data.
	A dataset describes a set of structured data, which is typically stored persistently in a database of some kind.
	To abstract away from a particular database implementation,
	we represent data elements as triples.
	This makes our theory valid for any kind of database that triples can represent,
	such as SQL databases, object-oriented databases, graph databases, triple stores, and other no-SQL databases

	Before defining datasets, we must first define the constituent notions of atom, concept, relation, rule, and role.
\subsection{Atoms}
	Atoms are values that have no internal structure, meant to represent data elements in a database.
	From a business perspective, atoms are used to represent concrete items of the world,
	such as \atom{Peter}, \atom{1}, or \atom{the king of France}.
	By convention throughout the remainder of this paper, variables $a$, $b$, and $c$ are used to represent \emph{atoms}.
	The set of atoms is called $\atoms$.
	
\subsection{Concepts}
	Concepts are names we use to classify atoms in a meaningful way.
	For example, you might choose to classify \atom{Peter} as a \concept{Person}, and \atom{074238991} as a \concept{TelephoneNumber}.
	In this example, \concept{Person} and \concept{TelephoneNumber} are concepts.
    We will use variables $A$, $B$, $C$, $D$ to represent concepts.
	The term $\ident{A}$ represents the \emph{identity relation} of concept $A$.
	The expression $a\ \inst\ A$ means that atom $a$ is an \emph{instance} of concept $A$.
	The statement $A\isa B$ (pronounce: $A$ is a $B$) states that any instance of $A$ is an instance of $B$ as well.
	We call this {\em specialization}, but it is also known as {\em generalization} or {\em subtyping}.
	Specialization is needed to allow statements such as: ``A woman is a human'' or ``A human is a mammal''.
	The set of concepts is called $\concepts$.
	
\subsection{Triples}
	A triple $\triple{\text{\atom{Peter}}}{\id{phone}}{\text{\atom{074238991}}}$ might mean that the ``thing'' that \atom{Peter} refers to
	has \atom{074238991} as a telephone number.
	Triples are used to relate two atoms and a relation.
	In the formal world, we leave it entirely up to a user to attach meaning to a triple.
	This ``meaning from practice'' has no consequences in the formal world.
	The set of triples is called $\triples$.

\subsection{Relations}
	Relations in datasets are used to store data.
	In this paper relations are represented by variables $r$, $s$, and $d$.

	Every relation $r$ contains a set of pairs, which we call the population of $r$:
\begin{equation}
	\pop{r}\ =\ \{ \pair{a}{b}|\ \triple{a}{r}{b}\in\triples\}
\end{equation}
	Every relation has a name, a source concept, and a target concept.
	We write $\declare{nm}{A}{B}$ to denote a relation with name \id{nm}, source concept $A$, and target concept $B$.
	% To disassemble a relation in its name, source and target, there exist three functions:
% \[\begin{array}[3]{rcl}
	% \id{relname}&:&\rels\rightarrow\id{RelationIdentifier}\\
	% \id{src}&:&\rels\rightarrow\concepts\\
	% \id{tgt}&:&\rels\rightarrow\concepts
% \end{array}\]
	% Or, stated otherwise, the denotation $\declare{nm}{A}{B}$ stands for a relation with
	% \(\relname{\declare{nm}{A}{B}} = \id{nm}\),
	% \(\src{\declare{nm}{A}{B}}=A\), and
	% \(\tgt{\declare{nm}{A}{B}}=B\).

	The pair $\pair{A}{B}$ is called the \emph{signature} of the relation.
	The term $\fullt{A}{B}$ represents the \emph{universal relation} over concept symbols $A$ and $B$.
	It contains all pairs that can be made of elements of $A$ and $B$:
\[\pop{\fullt{A}{B}} = \{ \pair{a}{b}| a\ \inst\ A, \}\]
	The term $\ident{A}$ represents the \emph{identity relation} over concept $A$.
	The set of relations is called $\rels$.

% \subsection{Roles}
% 	A role is a name that identifies a group of users that get the same privileges in a data set.
% 	The set of roles is called $\roles$.
	
\subsection{Constraints}
	Each constraint $u\in\rules$ has a signature $\signat{u}$, which is a pair of concepts.
	Each constraint $u$ also has a function $\id{viol}_u:\powerset{\atoms\times\rels\times\atoms}\ \rightarrow\ \powerset{\atoms\times\atoms}$.
	We call the set $\viol{\triples}{u}$ the \define{violation set} of constraint $u$ in population $\triples$.
	We call every element $\pair{a}{b}\in\viol{\triples}{u}$ a \define{violation} of constraint $u$ in $\triples$.
	Note that the signature of $u$ does not depend on the population, whereas the violation set of $u$ may be different for every $\triples$.
	The set of constraints is called $\rules$.

\subsection{Datasets}
	We can now define the notion of dataset.
	Let	$\concepts$ be a set of concept symbols,
	$\rels$ be a set of relations,
	$\atoms$ be a set of atoms,
	let $\inst$ be a relation $\atoms\times\concepts$ that represents the instance relation between concepts and atoms,
	% let $\roles$ be a set of roles,
	and $\rules$ be a set of constraints.
\begin{definition}[dataset]
	\label{def:dataset}
	\item A dataset is a tuple $\la\concepts,\isa,\rels,\atoms,\inst,\triples,\rules\ra$ with
	\[\begin{array}[3]{rcl}
		% \id{maintain}&:&\roles\times\rules\\
		\isa\text{\ is a partial order}\\
		\forall\triple{a}{r}{b}\in\triples&:&a\ \inst\ \src{r}\ \wedge\ b\ \inst\ \tgt{r}\\
		\forall a\in\atoms\ \exists A\in\concepts&:&a\ \inst\ A\\
		\forall u\in\rules&:&\viol{\triples}{u}=\emptyset
	\end{array}\]
\end{definition}

\subsection{Motivations}
	We have already motivated the use of triples in a dataset:
	It is a generic way of representing structured data, which maps to most (if not all) existing database technologies.
	Changes in the data means changing the set of triples, adding or removing triples from the set.
	That is not migration; that is regular operational behaviour.
	If the software changes, this means that the concepts, relations, and constraints change as well.
	However, a dataset can contain atoms that do not partake in any triple.
	That is why we need a set of atoms, $\atoms$ too.

	Atoms serve as data elements. Changes in the dataset are reflected in $\atoms$.
	Concepts serve to classify atoms in a partial order (the classification) so we can implement a typing regime on the dataset.
	This type system ensures that the dataset can be interpreted as a meaningful database.
	As a consequence, the relations $\isa$ and $\inst$

	The choice of elements in the tuple that represents a dataset is determined by the dynamics of a dataset.
	Anything that can change needs to be in that tuple.
	It is not only the data that changes. Rules can change, relations and concepts can change, the taxonomy can change,
	rules can change.
	In migrations we want to cope with any conceivable change,
	ensuring that the dataset satisfies its defining properties (from definition~\ref{def:dataset}).
	The migration must also ensure that the population remains intact as much as possible.



\section{Bibliography}
\bibliographystyle{elsarticle-harv}
\bibliography{doc}


\end{document}
