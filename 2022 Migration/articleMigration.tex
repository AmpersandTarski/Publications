\documentclass{elsarticle}
\usepackage{graphicx}
%\usepackage{multicol}
%\usepackage{footmisc}
\usepackage{amstext}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[english]{babel}
%\usepackage[official,right]{eurosym}
\selectlanguage{english}
\hyphenation{ExecEngine}
\newtheorem{lemma}{Lemma}
\def\Events{{\mathit E}}
\begin{document}
\include{preambleMigrations}

\title{A Theory for Migration of Information Systems}
\author[ou,ordina]{Stef Joosten\fnref{fn1}}
\ead{stef.joosten@ou.nl}
\author[umn]{Sebastiaan Joosten\fnref{fn2}}
\address[ou]{Open Universiteit Nederland, Heerlen, the Netherlands}
\address[ordina]{Ordina NV, Nieuwegein, the Netherlands}
\address[umn]{University of Minnesota, Minneapolis, USA}
\fntext[fn1]{ORCID 0000-0001-8308-0189}
\fntext[fn2]{ORCID 0000-0002-6590-6220}

\begin{abstract}
	The Ampersand project has provided the theory and tools to generate semantic information systems from an algebraic specification.
	However, information systems in practice may change repeatedly after their maiden deployment.
	Changes that affect the data model typically result in a data migration.
	In such cases, simply regenerating the system is not enough.

	In this contribution we develop a theory for data migration that aims at automating the migration,
	to enable more frequent migrations.
	A theory is needed to do this reliably, without mistakes.
	This paper proposes such a theory.

	The ultimate target is to generate the entire migration from two specifications: the as-is specification and the to-be specification.
	The theory for doing that is the topic of this paper.
	The software generator that embodies this theory is subject of future research.
\end{abstract}

\begin{keyword}
relation algebra\sep software development\sep data migration\sep software migration\sep Ampersand
\end{keyword}
\maketitle

\section{Introduction}
\label{sct:Introduction}

\section{Basics}
\label{sct:Basics}
	To define migration, we must introduce the notion of dataset
	because migration aims to preserve data while changing the software that manipulates data.
	A dataset describes a set of structured data, which is typically stored persistently in a database of some kind.
	To abstract away from a particular database implementation,
	we represent data elements as triples.
	This makes our theory valid for any kind of database that triples can represent,
	such as SQL databases, object-oriented databases, graph databases, triple stores, and other no-SQL databases

	Before defining datasets, we must first define the constituent notions of atom, concept, relation, rule, and role.
\subsection{Atoms}
	Atoms serve as data elements.
	They are values without internal structure of interest, meant to represent data elements in a database.
	From a business perspective, atoms are used to represent concrete items of the world,
	such as \atom{Peter}, \atom{1}, or \atom{the king of France}.
	By convention throughout the remainder of this paper, variables $a$, $b$, and $c$ are used to represent \emph{atoms}.
	The set of atoms is called $\atoms$.
	
\subsection{Concepts}
	Concepts are names we use to classify atoms in a meaningful way.
	For example, you might choose to classify \atom{Peter} as a \concept{Person}, and \atom{074238991} as a \concept{TelephoneNumber}.
	In this example, \concept{Person} and \concept{TelephoneNumber} are concepts.
    We will use variables $A$, $B$, $C$, $D$ to represent concepts.
	The term $\ident{A}$ represents the \emph{identity relation} of concept $A$.
	The expression $a\ \inst\ A$ means that atom $a$ is an \emph{instance} of concept $A$.
	The statement $A\isa B$ (pronounce: $A$ is a $B$) states that any instance of $A$ is an instance of $B$ as well.
	We call this {\em specialization}, but it is also known as {\em generalization} or {\em subtyping}.
	Specialization is needed to allow statements such as: ``A woman is a human'' or ``A human is a mammal''.
	The set of concepts is called $\concepts$.
	
\subsection{Triples}
	Triples are used to represent data.
	Each triple relates two atoms to a relation.
	A triple $\triple{\text{\atom{Peter}}}{\id{phone}}{\text{\atom{074238991}}}$ might mean that the ``thing'' that \atom{Peter} refers to
	has \atom{074238991} as a telephone number.
	In the formal world, we leave it entirely up to a user to attach meaning to a triple.
	This ``meaning from practice'' has no consequences in the formal world.
	The set of triples is called $\triples$.

\subsection{Relations}
	Relations in datasets are used to store data.
	In this paper relations are represented by variables $r$, $s$, and $d$.

	Every relation $r$ contains a set of pairs, which we call the population of $r$:
\begin{equation}
	\pop{r}\ =\ \{ \pair{a}{b}|\ \triple{a}{r}{b}\in\triples\}
\end{equation}
	Every relation has a name, a source concept, and a target concept.
	We write $\declare{nm}{A}{B}$ to denote a relation with name \id{nm}, source concept $A$, and target concept $B$.
	% To disassemble a relation in its name, source and target, there exist three functions:
% \[\begin{array}[3]{rcl}
	% \id{relname}&:&\rels\rightarrow\id{RelationIdentifier}\\
	% \id{src}&:&\rels\rightarrow\concepts\\
	% \id{tgt}&:&\rels\rightarrow\concepts
% \end{array}\]
	% Or, stated otherwise, the denotation $\declare{nm}{A}{B}$ stands for a relation with
	% \(\relname{\declare{nm}{A}{B}} = \id{nm}\),
	% \(\src{\declare{nm}{A}{B}}=A\), and
	% \(\tgt{\declare{nm}{A}{B}}=B\).

	The pair $\pair{A}{B}$ is called the \emph{signature} of the relation.
	The term $\fullt{A}{B}$ represents the \emph{universal relation} over concept symbols $A$ and $B$.
	It contains all pairs that can be made of elements of $A$ and $B$:
\[\pop{\fullt{A}{B}} = \{ \pair{a}{b}| a\ \inst\ A,\ b\ \inst\ B \}\]
	The term $\ident{A}$ represents the \emph{identity relation} over concept $A$.
	The set of relations is called $\rels$.

% \subsection{Roles}
% 	A role is a name that identifies a group of users that get the same privileges in a data set.
% 	The set of roles is called $\roles$.
	
\subsection{Constraints}
	Constraints are the invariants of a dataset: restrictions that are kept true at all times.
	Their purpose is to ensure the semantics of a dataset, i.e. the preservation of meaning as data changes.
	Each constraint $u\in\rules$ has a signature $\signat{u}$, which is a pair of concepts.
	Each constraint $u$ also has a function $\id{viol}_u:\powerset{\atoms\times\rels\times\atoms}\ \rightarrow\ \powerset{\atoms\times\atoms}$.
	We call the set $\viol{\triples}{u}$ the \define{violation set} of constraint $u$ in population $\triples$.
	We call every element $\pair{a}{b}\in\viol{\triples}{u}$ a \define{violation} of constraint $u$ in $\triples$.
	Note that the signature of $u$ does not depend on the population, whereas the violation set of $u$ may be different for every $\triples$.
	The set of constraints is called $\rules$.

\subsection{Datasets}
	We can now define the notion of dataset.
	Let	$\concepts$ be a set of concept symbols,
	let $\isa$ be a partial order on $\concepts$,
	let $\rels$ be a set of relations,
	let $\atoms$ be a set of atoms,
	let $\inst$ be a relation $\atoms\times\concepts$ that represents the instance relation between concepts and atoms,
	% let $\roles$ be a set of roles,
	and let $\rules$ be a set of constraints.
\begin{definition}[dataset]
	\label{def:dataset}
	\item A dataset is a tuple $\la\concepts,\isa,\rels,\atoms,\inst,\triples,\rules\ra$ with
	\begin{eqnarray}
		\forall r\in\rels&:&\src{r}\in\concepts\ \wedge\ \tgt{r}\in\concepts\\
		\forall a\in\atoms\ \exists A\in\concepts&:&a\ \inst\ A\\
		% \id{maintain}&:&\roles\times\rules\\
		\forall A,B\in\concepts, a\in\atoms&:&A\isa B\wedge a\ \inst\ A\ \Rightarrow\ a\ \inst\ B\\
		\forall\triple{a}{r}{b}\in\triples&:&r\in\rels\ \wedge\ a\ \inst\ \src{r}\ \wedge\ b\ \inst\ \tgt{r}\\
		\forall u\in\rules&:&\viol{\triples}{u}=\emptyset\label{violation free}
	\end{eqnarray}
\end{definition}

\subsection{Motivation}
% The purpose of this section is to explain why a dataset is structured the way it is.
	The challenge of migration is to preserve meaning rather than just copy data from one place to another.
	The bearer of meaning to users of a dataset is the data.
	That is represented by the population, i.e. the sets of triples and atoms, $\triples$ and $\atoms$.
	How a user interprets the data is up to the user and may therefore have no consequence to the dataset.
	So we attach no intrinsic meaning to a triple and take $\triples$ and $\atoms$ for granted.
	In a migration we seek to preserve that data where we can.
	The other elements in a dataset, $\isa$, $\concepts$, $\rels$, and $\rules$ do have consequences, however.
	Definition~\ref{def:dataset} implies that changes to data may cause violations of rules,
	so measures must be taken to get rid of those violations (eqn.~\ref{violation free}).
	Changes to $\isa$, $\concepts$, $\rels$ change the data structure in a dataset.
	Changes to $\rules$ change the invariants of the dataset.
	This paper studies those changes and seeks to preserve the rules in definition~\ref{def:dataset} in such a way that large portions of migration can be automated.

\section{Migration steps}
	A smooth migration from an old system to a new system would go as follows:
	Launch the new system in parallel to the old, copy data from the old to the new system, and have everyone use the new system.
	We identify the following possible issues in this approach:

	\begin{enumerate}
	\item Data required in the new system is missing in the old system.
	There may be no way in the old system to enter that data.
	An example could be that every reimbursement form needs to have an address associated to it to mail the check to, but address information is not stored in the old system:
	The old system required the reimbursement office to look up employee's addresses from a hand-written list they had on their desk.
	\item Data in the old system is wrong but cannot be corrected there due to how the old system was designed.
	An example is if the old system only allows approvals to be entered as the current user, and the CEO insists that her administrative staff enters his approvals into the system for her.
	This may result in approvals being entered as admin staff, where it was really the CEO making the approval.
	\item Data in the old system does not satisfy invariants of the new system.
	There may be no way in the old system of making the data satisfy those invariants. We can use the same example as in the previous bullet point, but add the requirement (in the new system) that every purchase above a certain amount needs to be approved by the CEO.
	\item A way of entering data into the old system is missing in the new system.
	People or automated processes might rely on these ways of entering data.
	An example could be that when employees turned their computers on or off, an ad-hoc script would automatically clock them in- and out to determine the number of hours they worked.
	A handful of employees still relies on this.
	\item Data present in the old system cannot be stored in the new system.
	An example could be that references to physical locations where original receipts are kept are stored in the old system, but the new system relies on scans of receipts and allows the originals to be destroyed or not submitted.
	Until the original receipts are scanned, the old data should be kept.
	\end{enumerate}
	
	To mitigate these issues, we:
	
	\begin{enumerate}
	\item Allow `missing' data-points requirements to be ignored during migration.
	\item Allow data-points to be migrated while being marked as needing correction.
	\item Allow invariants in the new system to be ignored for certain data-points during migration.
	\item Allow continued use of interfaces of the old system, data entered into the old system via those interfaces needs to be continuously copied to the new system.
	\item Retain data in the old system until it can be marked as ready to be phased out.
	\end{enumerate}	

\section{Bibliography}
\bibliographystyle{elsarticle-harv}
\bibliography{doc}


\end{document}
